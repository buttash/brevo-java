/*
 * Brevo API
 * Brevo provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/brevo  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  |
 *
 * OpenAPI spec version: 3.0.0
 * Contact: contact@brevo.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package brevoModel;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModelProperty;
import org.apache.commons.lang3.ObjectUtils;

import java.io.IOException;

/**
 * ExportWebhooksHistory
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2024-04-17T12:57:43.398+05:30")
public class ExportWebhooksHistory {
  @SerializedName("days")
  private Integer days = null;

  @SerializedName("startDate")
  private String startDate = null;

  @SerializedName("endDate")
  private String endDate = null;

  @SerializedName("sort")
  private String sort = null;

  /**
   * Filter the history based on webhook type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TRANSACTIONAL("transactional"),
    
    MARKETING("marketing");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("type")
  private TypeEnum type = null;

  /**
   * Filter the history for a specific event type
   */
  @JsonAdapter(EventEnum.Adapter.class)
  public enum EventEnum {
    INVALID_PARAMETER("invalid_parameter"),
    
    MISSING_PARAMETER("missing_parameter"),
    
    HARDBOUNCE("hardBounce"),
    
    SOFTBOUNCE("softBounce"),
    
    DELIVERED("delivered"),
    
    SPAM("spam"),
    
    REQUEST("request"),
    
    OPENED("opened"),
    
    CLICK("click"),
    
    INVALID("invalid"),
    
    DEFERRED("deferred"),
    
    BLOCKED("blocked"),
    
    UNSUBSCRIBED("unsubscribed"),
    
    ERROR("error"),
    
    UNIQUEOPENED("uniqueOpened"),
    
    LOADEDBYPROXY("loadedByProxy"),
    
    ALLEVENTS("allEvents");

    private String value;

    EventEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EventEnum fromValue(String text) {
      for (EventEnum b : EventEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<EventEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EventEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EventEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return EventEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("event")
  private EventEnum event = null;

  @SerializedName("notifyURL")
  private String notifyURL = null;

  @SerializedName("webhookId")
  private Integer webhookId = null;

  @SerializedName("email")
  private String email = null;

  @SerializedName("messageId")
  private Integer messageId = null;

  public ExportWebhooksHistory days(Integer days) {
    this.days = days;
    return this;
  }

   /**
   * Number of days in the past including today (positive integer). _Not compatible with &#39;startDate&#39; and &#39;endDate&#39;_
   * @return days
  **/
  @ApiModelProperty(example = "7", value = "Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_")
  public Integer getDays() {
    return days;
  }

  public void setDays(Integer days) {
    this.days = days;
  }

  public ExportWebhooksHistory startDate(String startDate) {
    this.startDate = startDate;
    return this;
  }

   /**
   * Mandatory if endDate is used. Starting date of the history (YYYY-MM-DD). Must be lower than equal to endDate
   * @return startDate
  **/
  @ApiModelProperty(example = "2023-02-13T00:00:00.000+0000", value = "Mandatory if endDate is used. Starting date of the history (YYYY-MM-DD). Must be lower than equal to endDate")
  public String getStartDate() {
    return startDate;
  }

  public void setStartDate(String startDate) {
    this.startDate = startDate;
  }

  public ExportWebhooksHistory endDate(String endDate) {
    this.endDate = endDate;
    return this;
  }

   /**
   * Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
   * @return endDate
  **/
  @ApiModelProperty(example = "2023-02-17T00:00:00.000+0000", value = "Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate")
  public String getEndDate() {
    return endDate;
  }

  public void setEndDate(String endDate) {
    this.endDate = endDate;
  }

  public ExportWebhooksHistory sort(String sort) {
    this.sort = sort;
    return this;
  }

   /**
   * Sorting order of records (asc or desc)
   * @return sort
  **/
  @ApiModelProperty(example = "desc", value = "Sorting order of records (asc or desc)")
  public String getSort() {
    return sort;
  }

  public void setSort(String sort) {
    this.sort = sort;
  }

  public ExportWebhooksHistory type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Filter the history based on webhook type
   * @return type
  **/
  @ApiModelProperty(example = "transactional", required = true, value = "Filter the history based on webhook type")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public ExportWebhooksHistory event(EventEnum event) {
    this.event = event;
    return this;
  }

   /**
   * Filter the history for a specific event type
   * @return event
  **/
  @ApiModelProperty(example = "request", required = true, value = "Filter the history for a specific event type")
  public EventEnum getEvent() {
    return event;
  }

  public void setEvent(EventEnum event) {
    this.event = event;
  }

  public ExportWebhooksHistory notifyURL(String notifyURL) {
    this.notifyURL = notifyURL;
    return this;
  }

   /**
   * Webhook URL to receive CSV file link
   * @return notifyURL
  **/
  @ApiModelProperty(example = "https://brevo.com", required = true, value = "Webhook URL to receive CSV file link")
  public String getNotifyURL() {
    return notifyURL;
  }

  public void setNotifyURL(String notifyURL) {
    this.notifyURL = notifyURL;
  }

  public ExportWebhooksHistory webhookId(Integer webhookId) {
    this.webhookId = webhookId;
    return this;
  }

   /**
   * Filter the history for a specific webhook id
   * @return webhookId
  **/
  @ApiModelProperty(example = "2345", value = "Filter the history for a specific webhook id")
  public Integer getWebhookId() {
    return webhookId;
  }

  public void setWebhookId(Integer webhookId) {
    this.webhookId = webhookId;
  }

  public ExportWebhooksHistory email(String email) {
    this.email = email;
    return this;
  }

   /**
   * Filter the history for a specific email
   * @return email
  **/
  @ApiModelProperty(example = "example@brevo.com", value = "Filter the history for a specific email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public ExportWebhooksHistory messageId(Integer messageId) {
    this.messageId = messageId;
    return this;
  }

   /**
   * Filter the history for a specific message id. Applicable only for transactional webhooks.
   * @return messageId
  **/
  @ApiModelProperty(example = "<23befbae-1505-47a8-bd27-e30ef739f32c@fr.sib>", value = "Filter the history for a specific message id. Applicable only for transactional webhooks.")
  public Integer getMessageId() {
    return messageId;
  }

  public void setMessageId(Integer messageId) {
    this.messageId = messageId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
    ExportWebhooksHistory exportWebhooksHistory = (ExportWebhooksHistory) o;
    return ObjectUtils.equals(this.days, exportWebhooksHistory.days) &&
    ObjectUtils.equals(this.startDate, exportWebhooksHistory.startDate) &&
    ObjectUtils.equals(this.endDate, exportWebhooksHistory.endDate) &&
    ObjectUtils.equals(this.sort, exportWebhooksHistory.sort) &&
    ObjectUtils.equals(this.type, exportWebhooksHistory.type) &&
    ObjectUtils.equals(this.event, exportWebhooksHistory.event) &&
    ObjectUtils.equals(this.notifyURL, exportWebhooksHistory.notifyURL) &&
    ObjectUtils.equals(this.webhookId, exportWebhooksHistory.webhookId) &&
    ObjectUtils.equals(this.email, exportWebhooksHistory.email) &&
    ObjectUtils.equals(this.messageId, exportWebhooksHistory.messageId);
  }

  @Override
  public int hashCode() {
    return ObjectUtils.hashCodeMulti(days, startDate, endDate, sort, type, event, notifyURL, webhookId, email, messageId);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExportWebhooksHistory {\n");
    
    sb.append("    days: ").append(toIndentedString(days)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    event: ").append(toIndentedString(event)).append("\n");
    sb.append("    notifyURL: ").append(toIndentedString(notifyURL)).append("\n");
    sb.append("    webhookId: ").append(toIndentedString(webhookId)).append("\n");
    sb.append("    email: ").append(toIndentedString(email)).append("\n");
    sb.append("    messageId: ").append(toIndentedString(messageId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

